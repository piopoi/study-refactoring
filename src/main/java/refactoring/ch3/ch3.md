# Chapter 03. 코드에서 나는 악취

- 챕터 3에서는 언제 어떤 리팩터링 기법을 사용해야 하는지 설명한다.

## 3.1 기이한 이름 (Mysterious Name)

- 이름만 잘 지어도 문맥 파악할 시간을 줄일 수 있다.
- 적당한 이름이 떠오르지 않는다면, 설계에 문제가 있을 수 있다.

## 3.2 중복 코드 (Duplicated Code)

### 중복 코드의 문제점

- 같은 클래스 내 중복: **함수 추출하기**로 공통 메서드 생성
- 유사한 코드: **문장 슬라이드하기**로 통합 후 함수 추출
- 서브클래스 중복: **메서드 올리기**로 부모 클래스에 통합

## 3.3 긴 함수 (Long Function)

- 짧은 함수는 간접 호출로 코드 이해, 공유, 선택을 쉽게 만든다.
- 함수를 짧게 만드는 작업의 대부분
  - **함수 추출하기(6.1절)**
- 함수에 매개변수와 임시 변수가 많아 추출이 힘들다면
  - **임시 변수를 질의 함수로 바꾸기(7.4절)** 로 임시 변수의 수를 줄이기.
  - **매개변수 객체 만들기(6.8절)** 와 **객체 통째로 넘기기(11.4절)** 로 매개변수의 수 줄이기.
  - 그래도 임시 변수와 매개변수가 너무 많다면, **함수를 명령으로 바꾸기(11.9절)**
- 추출할 코드를 찾는 데는 주석을 참고하는게 좋다.
  - 코드가 한 줄이어도 따로 설명할 필요가 있다면 함수로 추출하는 게 좋다.
- 조건문이나 반복문도 추출 대상이 된다.
  - **조건문 분해하기(6.1절)**
  - 조건문의 각 case 본문을 **함수 추출하기(6.1절)** 를 적용하여 함수로 추출.
  - 같은 조건을 기준으로 삼는 조건문이 여러 개라면 **조건부 로직을 다형성으로 바꾸기(10.4절)**.
- 반복문에 여러 작업이 섞여있다면
  - **반복문 쪼개기(8.7절)**

## 3.4 긴 매개변수 목록 (Long Parameter List)

- 긴 매개변수 목록은 이해하기 어려울 수 있다.
- 불필요한 매개변수 줄이기:
  - **매개변수를 질의 함수로 바꾸기(11.5절)**: 다른 매개변수에서 얻을 수 있는 값 제거.
  - **객체 통째로 넘기기(11.4절)**: 데이터 구조에서 값을 뽑아 전달하는 대신 원본 구조 사용.
  - **매개변수 객체 만들기(6.8절)**: 항상 함께 전달되는 매개변수를 하나로 묶기.
  - **플래그 인수 제거하기(11.3절)**: 함수의 동작을 결정하는 플래그 매개변수 제거.
- **여러 함수를 클래스로 묶기(6.9절)**: 특정 매개변수들을 여러 함수가 공통으로 사용할 때, 클래스를 만들어 필드로 저장.

## 3.5 전역 데이터 (Global Data)

- 전역 데이터(global data)는 코드 어디서든 접근할 수 있어, 변경 원인을 추적하기 어렵다.
  - 전역 변수, 클래스 변수, 싱글톤에서도 같은 문제 발생.
- 전역 데이터를 방지하는 리팩터링:
  - **변수 캡슐화하기(6.6절)**: 데이터를 함수로 감싸 접근과 수정을 통제.
  - 접근자 함수를 클래스나 모듈에 넣어 접근 범위를 최소화.
- 가변 전역 데이터는 특히 위험함.
  - 변경되지 않는 전역 데이터는 상대적으로 안전하지만, 언어 차원의 보장이 필요.
- 전역 데이터가 많아지면 유지보수가 어려워지므로, 조금만 있어도 캡슐화하는 것이 좋다.

## 3.6 가변 데이터 (Mutable Data)

- 가변 데이터(Mutable Data)의 문제점
  - 데이터 변경 시 예상치 못한 오류 발생 가능.
  - 다른 코드가 특정 값을 기대하는 상황에서 예상치 못한 변경이 일어나면 디버깅이 어려움.
  - 함수형 프로그래밍에서는 불변성을 유지하여 이러한 문제를 방지.
- 가변 데이터의 위험을 줄이는 리팩터링 기법
  - **변수 캡슐화하기(6.6절)**: 함수를 통해 값을 수정하도록 제한.
  - **변수 쪼개기(9.1절)**: 용도가 다른 값을 하나의 변수에 저장하는 대신 독립 변수로 분리.
  - **문장 슬라이드하기(8.6절), 함수 추출하기(6.1절)**: 부작용이 없는 코드와 갱신 로직을 분리.
  - **질의 함수와 변경 함수 분리하기(11.1절)**: 부작용을 최소화.
  - **세터 제거하기(11.7절)**: 세터 호출을 줄여 변수 유효범위 축소.
  - **파생 변수를 질의 함수로 바꾸기(9.3절)**: 불필요한 가변 데이터 제거.
- 변수 유효범위를 좁히면 가변 데이터의 위험 감소.
  - **여러 함수를 클래스로 묶기(6.9절)**, **변환 함수로 묶기(6.10절)**: 변수 갱신 범위를 한정.
  - **참조를 값으로 바꾸기(9.4절)**: 내부 필드 수정 대신 전체 구조체를 교체.
- 가변 데이터는 유지보수성과 안정성을 저하시킬 수 있음.
- 불변성을 최대한 유지하면서 필요한 경우 리팩터링을 통해 가변성을 제어하는 것이 중요.

## 3.7 뒤엉킨 변경 (Divergent Change)

- 뒤엉킨 변경은 하나의 모듈이 여러 이유로 변경될 때 발생한다. 이는 **단일 책임 원칙(SRP)**이 지켜지지 않으면 나타난다.
  - 새로운 데이터베이스를 추가할 때 여러 함수들을 수정해야 한다면 뒤엉킨 변경이 발생한 것이다.
  - 금융 상품을 추가할 때도 여러 함수들을 수정해야 한다면 마찬가지이다.
- 이를 방지하려면 기능을 역할별로 분리하여 유지보수 가능하게 만들어야 한다.
  - **단계 쪼개기(6.11절)**: 순차적으로 실행되는 작업이라면 단계를 분리하여 처리한다.
  - **함수 옮기기(8.1절)**: 특정 맥락에 해당하는 함수들을 하나의 모듈로 묶는다.
  - **함수 추출하기(6.1절)**: 여러 맥락을 다루는 함수는 역할에 맞게 추출한다.
  - **클래스 추출하기(7.5절)**: 모듈이 클래스라면 클래스 단위로 역할을 분리한다.
- 중요한 점은 변경 이유가 다른 기능들을 명확히 구분하고, 적절하게 모듈화하여 뒤엉킨 변경을 방지하는 것이다.

## 3.8 산탄총 수술 (Shotgun Surgery)

- 산탄총 수술(Shotgun Surgery)
  - 뒤엉킨 변경(3.7절)과 반대되는 개념
  - 하나의 변경을 위해 여러 클래스를 자잘하게 수정해야 하는 상황
  - 변경 부분이 코드 전반에 퍼져있어 누락 위험이 높음
- 관련 요소들을 한 모듈로 모으기
  - **함수 옮기기(8.1절)**
  - **필드 옮기기(8.2절)**
- 비슷한 데이터를 다루는 경우
  - **여러 함수를 클래스로 묶기(6.9절)**
- 데이터 구조 변환/보강 함수들
  - **여러 함수를 변환 함수로 묶기(6.10절)**
- 함수들의 출력을 다음 단계로 전달
  - **단계 쪼개기(6.11절)**
- 어설프게 분리된 로직 처리
  - **함수 인라인하기(6.2절)**
  - **클래스 인라인하기(7.6절)**
  - 일시적으로 코드가 비대해지더라도 나중에 더 좋은 형태로 추출 가능

## 3.9 기능 편애 (Feature Envy)

- 기능 편애(Feature Envy)
  - 한 함수가 자신이 속한 모듈보다 다른 모듈의 함수나 데이터와 더 많이 상호작용하는 현상
  - 주로 외부 객체의 게터 메서드를 많이 호출하는 형태로 나타남
- **함수 옮기기(8.1절)** 로 함수를 관련 데이터가 있는 모듈로 이동
- 함수 일부만 문제가 된다면
  - **함수 추출하기(6.1절)** 로 해당 부분을 분리
  - **함수 옮기기(8.1절)** 로 추출된 함수를 적절한 모듈로 이동
- 이동할 모듈 선택이 어려울 때
  - 가장 많은 데이터를 포함한 모듈로 이동
  - **함수 추출하기(6.1절)** 로 여러 조각으로 나눈 후 각각 적절한 모듈로 이동
- 예외적인 패턴들
  - 전략 패턴(Strategy Pattern)
  - 방문자 패턴(Visitor Pattern)1
  - 자기 위임(Self-Delegation)
  - 이러한 패턴들은 뒤엉킨 변경 냄새를 제거하는데 활용
  - 동작 코드를 각 클래스로 격리하여 수정을 용이하게 함

## 3.10 데이터 뭉치 (Data Clumps)

- 데이터 뭉치(Data Clumps)
  - 여러 곳에서 항상 함께 다니는 데이터 항목들
  - 클래스의 필드나 메서드 시그니처에서 자주 발견됨
- 데이터 뭉치 판별법
  - 값 하나를 제거했을 때 나머지 데이터만으로는 의미가 없다면 데이터 뭉치
- 필드 형태의 데이터 뭉치 처리
  - **클래스 추출하기(7.5절)** 로 별도 클래스로 분리
- 메서드 시그니처의 데이터 뭉치 처리
  - **매개변수 객체 만들기(6.8절)**
  - **객체 통째로 넘기기(11.4절)**
  - 새 객체가 일부 필드만 사용하더라도, 두 개 이상이면 의미있는 개선
- 클래스로 추출 시 장점
  - 관련 동작도 함께 옮길 수 있음
  - 중복 제거 가능
  - 향후 개발 가속화에 도움되는 유용한 클래스로 발전 가능

## 3.11 기본형 집착 (Primitive Obsession)

- 프로그래머들이 문제에 맞는 기초 타입을 정의하기를 꺼리는 현상
- 흔한 사례들:
  - 금액을 단순 숫자형으로 처리
  - 물리량 계산시 단위 무시
  - 범위를 if 조건문으로만 처리
  - 전화번호를 단순 문자열로 처리
- 특히 문자열 사용에서 두드러짐

  - '문자열화된(stringly typed)' 변수라는 용어 존재
  - 전화번호와 같이 형식이 필요한 데이터를 단순 문자열로 처리

- 해결 방법
  - **기본형을 객체로 바꾸기(7.3절)**
  - 타입 코드로 사용된 경우
    - **타입 코드를 서브클래스로 바꾸기(12.6절)**
    - **조건부 로직을 다형성으로 바꾸기(10.4절)**
  - 함께 다니는 기본형 그룹은
    - **매개변수 객체 만들기(6.8절)**로 처리
